---
title: "degauss_template.Rmd"
author: "Erika Rasnick"
date: "September 24, 2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r prep, eval = FALSE, echo = FALSE}
# use these variables along with the find/replace function to update globally
geomarker <- basename(here::here())
container_version <- 0.1.0
r_version <- dht::detect_r_version()
renv_version <- packageVersion("renv")
```

```{text dockerfile, eval = FALSE, echo = FALSE}
FROM rocker/r-ver:4.0.4

# install required version of renv
RUN R --quiet -e "install.packages('remotes', repos = 'https://cran.rstudio.com')"
# make sure version matches what is used in the project: packageVersion('renv')
ENV RENV_VERSION 0.14.0
RUN R --quiet -e "remotes::install_github('rstudio/renv@${RENV_VERSION}')"

WORKDIR /app

RUN apt-get update \
  && apt-get install -yqq --no-install-recommends \
  libgdal-dev \
  libgeos-dev \
  libudunits2-dev \
  libproj-dev \
  libv8-dev \
  && apt-get clean

COPY renv.lock .
RUN R --quiet -e "renv::restore(repos = c(CRAN = 'https://packagemanager.rstudio.com/all/__linux__/focal/latest'))"

ADD https://geomarker.s3.us-east-2.amazonaws.com/geometries/census_tracts_1970_to_2020.rds census_tracts_1970_to_2020.rds
COPY entrypoint.R .

WORKDIR /tmp

ENTRYPOINT ["/app/entrypoint.R"]
```

```{r rscript, eval = FALSE, echo = FALSE}
#!/usr/local/bin/Rscript

dht::greeting(geomarker_name = 'st_census_tract', 
              version = '0.1.0', 
              description = 'links geocoded coordinates with date ranges to cooresponding census tracts from the appropriate vintage')

old_warn <- getOption("warn")
options(warn = -1)

library(dht)
qlibrary(readr)
qlibrary(dplyr)
qlibrary(tidyr)
qlibrary(sf)

options(warn = old_warn)

doc <- '
      Usage:
      entrypoint.R <filename>
      '

opt <- docopt::docopt(doc)
## for interactive testing
## opt <- docopt::docopt(doc, args = 'test/my_address_file_geocoded.csv')

message('reading input file...')
raw_data <- readr::read_csv(opt$filename)

dht::check_for_column(raw_data, 'lat', raw_data$lat)
dht::check_for_column(raw_data, 'lon', raw_data$lon)
dht::check_for_column(raw_data, 'start_date', raw_data$start_date)
dht::check_for_column(raw_data, 'end_date', raw_data$end_date)
raw_data$start_date <- dht::check_dates(raw_data$start_date)
raw_data$end_date <- dht::check_dates(raw_data$end_date)
dht::check_end_after_start_date(raw_data$start_date, raw_data$end_date)

raw_data$.row <- seq_len(nrow(raw_data))

d <-
  raw_data %>%
  select(.row, lat, lon, start_date, end_date) %>%
  na.omit() 

message('determining census decade for each date range...')
d <- d %>% 
  mutate(min_year = glue::glue('{floor(lubridate::year(start_date) / 10)}0'), 
         max_year = glue::glue('{floor(lubridate::year(end_date) / 10)}0')) %>% 
  group_by(.row) %>% 
  nest() %>% 
  mutate(year_seq = purrr::map(data, ~seq(.x$min_year, .x$max_year, 10))) %>% 
  unnest(cols = c(data, year_seq)) %>% 
  mutate(day1 = as.Date(glue::glue('{year_seq}-01-01')), 
         dayx = as.Date(glue::glue('{year_seq + 9}-12-31')),
         new_start_date = if_else(start_date > day1, start_date, day1), 
         new_end_date = if_else(end_date < dayx, end_date, dayx),
         census_tract_vintage = glue::glue('{floor(lubridate::year(new_start_date) / 10)}0')) 
         
cli::cli_alert_warning('{nrow(unique(d[d$min_year != d$max_year, d$.row]))} date range{?s} span{?s/} more than one census decade and will be split to one row per decade.')

d <- d %>% 
  select(.row, lat, lon, 
         start_date = new_start_date, 
         end_date = new_end_date, 
         census_tract_vintage) %>% 
  group_by(lat, lon) %>%
  nest(.rows = c(.row)) %>%
  st_as_sf(coords = c('lon', 'lat'), crs = 4326) %>% 
  st_transform(5072)

d <- d %>%
  split(f = d$census_tract_vintage)

message('loading census tract shapefiles...')
all_tracts <- readRDS('/app/census_tracts_1970_to_2020.rds')

tracts_to_join <- all_tracts[names(all_tracts) == names(d)]

message('joining to census tracts...')
d <- purrr::map2(d, tracts_to_join, ~suppressWarnings(st_join(.x, .y, largest = TRUE))) %>% 
  bind_rows() %>% 
  st_drop_geometry()

## merge back on .row after unnesting .rows into .row
dht::write_geomarker_file(d = d,
                          raw_data = raw_data %>% select(-start_date, -end_date),
                          filename = opt$filename,
                          geomarker_name = 'st_census_tract',
                          version = '0.1.0')
```

```{text dockerignore, eval = FALSE, echo = FALSE}
# ignore everything
**

# except what we need
!/renv.lock
!/entrypoint.R
```

```{text gitignore, eval = FALSE, echo = FALSE}
*.rds
*.fst
*.qs
.Rproj.user
```

```{r test-dir, eval = FALSE, echo = FALSE, cache = TRUE}
test_dir <- fs::path_join(c(here::here(), '/test'))
fs::dir_create(test_dir)
readr::write_csv(dht:::my_address_file_geocoded,
                   fs::path_join(c(test_dir, 'my_address_file_geocoded.csv')))
```


```{text makefile, eval = FALSE, echo = FALSE}
REGISTRY_HOST=docker.io
USERNAME=degauss
NAME=$(shell basename "$(CURDIR)")
IMAGE=$(REGISTRY_HOST)/$(USERNAME)/$(NAME)

.PHONY: build test shell release clean tag-gh

build:
	docker build -t $(IMAGE) .

test:
	docker run --rm -v "${PWD}/test":/tmp $(IMAGE) my_address_file_geocoded.csv

shell:
	docker run --rm -it --entrypoint=/bin/bash -v "${PWD}/test":/tmp $(IMAGE)

release:
ifndef VERSION
	$(error VERSION is not set. Usage: "make release VERSION=X.X")
endif
ifndef DOCKER_USERNAME
	$(error DOCKER_USERNAME is not set)
endif
ifndef DOCKER_PAT
	$(error DOCKER_PAT is not set)
endif
	git commit -am "Release for image version $(VERSION)" --allow-empty
	git tag -a $(VERSION) -m "${VERSION}"
	git push origin ${VERSION}
	git push
	echo "${DOCKER_PAT}" | docker login -u "${DOCKER_USERNAME}" --password-stdin
	docker tag ${IMAGE}:latest ${IMAGE}:${VERSION}
	docker push ${IMAGE}:${VERSION}
	docker push ${IMAGE}:latest

clean:
	docker system prune -f

tag-gh:
ifndef VERSION
	$(error VERSION is not set. Usage: "make release VERSION=X.X")
endif
	docker tag $(IMAGE) ghcr.io/degauss-org/$(NAME):$(VERSION)
```

```{r license, eval = FALSE, echo = FALSE}
usethis::use_gpl3_license()
```

```{r actions-dir, eval = FALSE, echo = FALSE, cache = TRUE}
actions_dir <- fs::path_join(c(here::here(), '/.github/workflows'))
fs::dir_create(actions_dir)
```

```{text actions}
name: Build & Deploy Docker Containers
on:
  # We'll trigger this workflow when a PR is submitted to make sure
  # your application still builds successfully with the new commits.
  pull_request: []
  # We'll also trigger this workflow when you want to deploy your container.
  # This means any push to main. You might want to do a release trigger.
  push:
    branches:
      - main
      - master
  # Let's also trigger a build and publish of your container when
  # you release a new version. You can use "created" here instead of published.
  release:
    types: [published]

jobs:
  deploy-images:
    runs-on: ubuntu-latest

    # Define your registry and repository here.
    # These are for the GitHub Container registry, you can also use
    # Quay.io or another OCI registry
    env:
      registry: ghcr.io
      username: degauss-org
      repository: st_census_tract

    strategy:
      # Even if one docker container build fails we want the others to continue.
      fail-fast: false
      # A matrix of Dockerfile paths and associated tags
      # Dockerfile in root builds to tag latest
      matrix:
        dockerfile: [[Dockerfile, latest]]
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Set Container Tag Normal
        run: |
          container="${{ env.registry }}/${{ env.username}}/${{ env.repository }}:${{ matrix.dockerfile[1] }}"
          echo "container=${container}" >> $GITHUB_ENV
        # On a new release create a container with the same tag as the release.
      - name: Set Container Tag Release
        if: github.event_name == 'release'
        run: |
          versioned="${{ env.registry }}/${{ env.username}}/${{ env.repository }}:${GITHUB_REF##*/}"
          echo "versioned=${versioned}" >> $GITHUB_ENV
        # On a PR create a "test" container with the same tag as the branch name.
      - name: Set Branch Tag Release
        if: github.event_name == 'pull_request'
        run: |
          versioned="${{ env.registry }}/${{ env.username}}/${{ env.repository }}:${GITHUB_HEAD_REF}"
          echo "versioned=${versioned}" >> $GITHUB_ENV
      - name: Build ${{ matrix.dockerfile[1] }}
        run: |
          printf "Preparing to build ${{ env.container }} from ${{ matrix.dockerfile[0] }}"
          if [ ! -f "${{ matrix.dockerfile[0]}}" ]; then
              printf "Dockerfile ${{ matrix.dockerfile[0] }} does not exist"
              exit 1;
          fi
          docker build -f ${{ matrix.dockerfile[0] }} -t ${{ env.container }} .
          docker images
      - name: Test ${{ matrix.dockerfile[1] }}
        run: |
          printf "Testing ${{ env.container }}"
          docker run --rm -v "${PWD}/test":/tmp ${{ env.container }} my_address_file_geocoded.csv
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v1
        with:
          registry: ${{ env.registry }}
          username: ${{ env.username }}
          password: ${{ secrets.GITHUB_TOKEN }}

          # Example variables for a non GitHub registry like Quay or Docker Hub
          # username: ${{ secrets.DOCKERHUB_USERNAME }}
          # password: ${{ secrets.DOCKERHUB_TOKEN }}

     # Deploy branch container on pull request
      - name: Test Deploy ${{ env.versioned }}
        if: github.event_name == 'pull_request'
        run: |
          docker tag ${{ env.container }} ${{ env.versioned }}
          docker push ${{ env.versioned }}
    # Deploy release container on release
      - name: Deploy ${{ env.versioned }}
        if: github.event_name == 'release'
        run: |
          docker tag ${{ env.container }} ${{ env.versioned }}
          docker push ${{ env.versioned }}
          docker push ${{ env.container }}
```

# st_census_tract <a href='https://degauss.org'><img src='https://github.com/degauss-org/degauss_template/raw/master/DeGAUSS_hex.png' align='right' height='138.5' /></a>


> link geocoded coordinates with date ranges to cooresponding census tracts from the appropriate vintage

[![Docker Build Status](https://img.shields.io/docker/automated/degauss/st_census_tract)](https://hub.docker.com/repository/docker/degauss/st_census_tract/tags)
[![GitHub Latest Tag](https://img.shields.io/github/v/tag/degauss-org/st_census_tract)](https://github.com/degauss-org/st_census_tract/releases)

## DeGAUSS example call

If `my_address_file_geocoded.csv` is a file in the current working directory with coordinate columns named `lat`, `lon`, `start_date`, and `end_date`, then

```sh
docker run --rm -v $PWD:/tmp degauss/st_census_tract:0.1.0 my_address_file_geocoded.csv
```

will produce `my_address_file_geocoded_st_census_tract_v0.1.0.csv` with an added columns named `census_tract_vintage` and `census_tract_id`. 

## geomarker methods

Input data must have columns called `lat` and `lon` containing the latitude and longitude, respecitvely, as well as `start_date` and `end_date` specifying a date range over which tract-level geomarkers will be assessed. The date range will be used to assign a census tract vintage, ranging from 1970 to 2020 by decade. If you do not have temporal data and wish to use the 2010 tract or block group boundaries, you can utilize the [census_block_group](https://degauss.org/census_block_group) DeGAUSS container. 

After the vintage is assigned, the latitude and longitude will be overlayed within a tract to assign a census tract identifier from the appropriate decade.

If the date range spans two census decades, the result will contain one row per decade. For example, 

| id | lat | lon | start_date | end_date |
|---:|----:|----:|------------|----------|
|1234| 39.15852 | -84.41757 | 2019-12-27	| 2020-01-03	|

would become

| id | lat | lon | start_date | end_date | census_tract_vintage | census_tract_id |
|---:|----:|----:|------------|----------|------------:|----------:|
|1234| 39.15852 | -84.41757 | **2019-12-27**	| **2019-12-31**	| 2019 | 39061005400 |
|1234| 39.15852 | -84.41757 | **2020-01-01**	| **2020-01-03**	| 2020 | 39061027600 |

where a 2019 tract identifier is assigned to the first row, and a 2020 tract identifier is assigned to the second row.

## geomarker data

- census tract boundaries were obtained from [NHGIS](https://www.nhgis.org/) and transformed to crs 5072
- census tract boundaries used in this container are stored at [`s3://geomarker/geometries/census_tracts_1970_to_2020.rds`](https://geomarker.s3.us-east-2.amazonaws.com/geometries/census_tracts_1970_to_2020.rds)

## DeGAUSS details

For detailed documentation on DeGAUSS, including general usage and installation, please see the [DeGAUSS homepage](https://degauss.org).

```{r development-1, eval=FALSE, echo = FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
dht::inflate(rmd = "dev/degauss_template.Rmd")
```

